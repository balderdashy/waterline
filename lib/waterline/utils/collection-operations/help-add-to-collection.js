/**
 * Module dependencies
 */

var assert = require('assert');
var _ = require('@sailshq/lodash');



/**
 * helpAddToCollection()
 *
 * @param  {Dictionary}   query  [stage 2 query]
 * @param  {Ref}   orm
 * @param  {Function} done
 */

module.exports = function helpAddToCollection(query, orm, cb) {

  // Validate arguments
  if (_.isUndefined(query) || !_.isPlainObject(query)) {
    throw new Error('Consistency violation: Invalid arguments - missing `stageTwoQuery` argument.');
  }

  if (_.isUndefined(orm) || !_.isPlainObject(orm)) {
    throw new Error('Consistency violation: Invalid arguments - missing `orm` argument.');
  }



  // Get the model being used as the parent
  var WLModel = orm.collections[query.using];
  assert.equal(query.using.toLowerCase(), query.using, '`query.using` (identity) should have already been normalized before getting here!  But it was not: '+query.using);

  // Look up the association by name in the schema definition.
  var schemaDef = WLModel.schema[query.collectionAttrName];

  // Look up the associated collection using the schema def which should have
  // join tables normalized
  var WLChild = orm.collections[schemaDef.collection];
  assert.equal(schemaDef.collection.toLowerCase(), schemaDef.collection, '`schemaDef.collection` (identity) should have already been normalized before getting here!  But it was not: '+schemaDef.collection);
  assert.equal(schemaDef.referenceIdentity.toLowerCase(), schemaDef.referenceIdentity, '`schemaDef.referenceIdentity` (identity) should have already been normalized before getting here!  But it was not: '+schemaDef.referenceIdentity);
  assert.equal(Object.getPrototypeOf(WLChild).identity.toLowerCase(), Object.getPrototypeOf(WLChild).identity, '`Object.getPrototypeOf(WLChild).identity` (identity) should have already been normalized before getting here!  But it was not: '+Object.getPrototypeOf(WLChild).identity);


  // Flag to determine if the WLChild is a manyToMany relation
  var manyToMany = false;

  // Check if the schema references something other than the WLChild
  if (schemaDef.referenceIdentity !== Object.getPrototypeOf(WLChild).identity) {
    manyToMany = true;
    WLChild = orm.collections[schemaDef.referenceIdentity];
  }

  // Check if the child is a join table
  if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
    manyToMany = true;
  }

  // Check if the child is a through table
  if (_.has(Object.getPrototypeOf(WLChild), 'throughTable') && _.keys(WLChild.throughTable).length) {
    manyToMany = true;
  }

  // Ensure the query skips lifecycle callbacks
  // Build a modified shallow clone of the originally-provided `meta`
  var modifiedMeta = _.extend({}, query.meta || {}, { skipAllLifecycleCallbacks: true });


  //  ███╗   ███╗ █████╗ ███╗   ██╗██╗   ██╗    ████████╗ ██████╗     ███╗   ███╗ █████╗ ███╗   ██╗██╗   ██╗
  //  ████╗ ████║██╔══██╗████╗  ██║╚██╗ ██╔╝    ╚══██╔══╝██╔═══██╗    ████╗ ████║██╔══██╗████╗  ██║╚██╗ ██╔╝
  //  ██╔████╔██║███████║██╔██╗ ██║ ╚████╔╝        ██║   ██║   ██║    ██╔████╔██║███████║██╔██╗ ██║ ╚████╔╝
  //  ██║╚██╔╝██║██╔══██║██║╚██╗██║  ╚██╔╝         ██║   ██║   ██║    ██║╚██╔╝██║██╔══██║██║╚██╗██║  ╚██╔╝
  //  ██║ ╚═╝ ██║██║  ██║██║ ╚████║   ██║          ██║   ╚██████╔╝    ██║ ╚═╝ ██║██║  ██║██║ ╚████║   ██║
  //  ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝          ╚═╝    ╚═════╝     ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝
  //
  // If the collection uses a join table, build a query that inserts the records
  // into the table.
  if (manyToMany) {

    //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┬─┐┌─┐┌─┐┌─┐┬─┐┌─┐┌┐┌┌─┐┌─┐  ┌┬┐┌─┐┌─┐┌─┐┬┌┐┌┌─┐
    //  ╠╩╗║ ║║║   ║║  ├┬┘├┤ ├┤ ├┤ ├┬┘├┤ ││││  ├┤   │││├─┤├─┘├─┘│││││ ┬
    //  ╚═╝╚═╝╩╩═╝═╩╝  ┴└─└─┘└  └─┘┴└─└─┘┘└┘└─┘└─┘  ┴ ┴┴ ┴┴  ┴  ┴┘└┘└─┘
    //
    // Maps out the parent and child attribute names to use for the query.
    var parentReference;
    var childReference;

    // Find the parent reference
    if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
      // Assumes the generated junction table will only ever have two foreign key
      // values. Should be safe for now and any changes would need to be made in
      // Waterline-Schema where a map could be formed anyway.
      _.each(WLChild.schema, function(wlsAttrDef, key) {
        if (!_.has(wlsAttrDef, 'references')) {
          return;
        }

        // If this is the piece of the join table, set the parent reference.
        if (_.has(wlsAttrDef, 'columnName') && wlsAttrDef.columnName === schemaDef.on) {
          parentReference = key;
        }
      });
    }
    //‡
    // If it's a through table, grab the parent and child reference from the
    // through table mapping that was generated by Waterline-Schema.
    else if (_.has(Object.getPrototypeOf(WLChild), 'throughTable')) {
      childReference = WLChild.throughTable[WLModel.identity + '.' + query.collectionAttrName];
      _.each(WLChild.throughTable, function(rhs, key) {
        if (key !== WLModel.identity + '.' + query.collectionAttrName) {
          parentReference = rhs;
        }
      });
    }

    // Find the child reference in a junction table
    if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
      // Assumes the generated junction table will only ever have two foreign key
      // values. Should be safe for now and any changes would need to be made in
      // Waterline-Schema where a map could be formed anyway.
      _.each(WLChild.schema, function(wlsAttrDef, key) {
        if (!_.has(wlsAttrDef, 'references')) {
          return;
        }

        // If this is the other piece of the join table, set the child reference.
        if (_.has(wlsAttrDef, 'columnName') && wlsAttrDef.columnName !== schemaDef.on) {
          childReference = key;
        }
      });
    }


    //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
    //  ╠╩╗║ ║║║   ║║  │─┼┐│ │├┤ ├┬┘└┬┘
    //  ╚═╝╚═╝╩╩═╝═╩╝  └─┘└└─┘└─┘┴└─ ┴

    // Build an array to hold all the records being inserted
    var joinRecords = [];

    // For each target record, build an insert query for the associated records.
    _.each(query.targetRecordIds, function(targetId) {
      _.each(query.associatedIds, function(associatedId) {
        var record = {};
        record[parentReference] = targetId;
        record[childReference] = associatedId;
        joinRecords.push(record);
      });
    });


    //  ╦═╗╦ ╦╔╗╔  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
    //  ╠╦╝║ ║║║║  │─┼┐│ │├┤ ├┬┘└┬┘
    //  ╩╚═╚═╝╝╚╝  └─┘└└─┘└─┘┴└─ ┴
    WLChild.createEach(joinRecords, cb, modifiedMeta);

    return;
  }//-•


  //  ██████╗ ███████╗██╗      ██████╗ ███╗   ██╗ ██████╗ ███████╗    ████████╗ ██████╗
  //  ██╔══██╗██╔════╝██║     ██╔═══██╗████╗  ██║██╔════╝ ██╔════╝    ╚══██╔══╝██╔═══██╗
  //  ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██║  ███╗███████╗       ██║   ██║   ██║
  //  ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██║   ██║╚════██║       ██║   ██║   ██║
  //  ██████╔╝███████╗███████╗╚██████╔╝██║ ╚████║╚██████╔╝███████║       ██║   ╚██████╔╝
  //  ╚═════╝ ╚══════╝╚══════╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚══════╝       ╚═╝    ╚═════╝
  //
  // Otherwise the child records need to be updated to reflect the new foreign
  // key value. Because in this case the targetRecordIds **should** only be a
  // single value, just an update here should do the trick.


  //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
  //  ╠╩╗║ ║║║   ║║  │─┼┐│ │├┤ ├┬┘└┬┘
  //  ╚═╝╚═╝╩╩═╝═╩╝  └─┘└└─┘└─┘┴└─ ┴


  // Build up a search criteria
  var criteria = {
    where: {}
  };

  criteria.where[WLChild.primaryKey] = query.associatedIds;

  // Build up the values to update
  var valuesToUpdate = {};
  valuesToUpdate[schemaDef.via] = _.first(query.targetRecordIds);


  //  ╦═╗╦ ╦╔╗╔  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
  //  ╠╦╝║ ║║║║  │─┼┐│ │├┤ ├┬┘└┬┘
  //  ╩╚═╚═╝╝╚╝  └─┘└└─┘└─┘┴└─ ┴

  WLChild.update(criteria, valuesToUpdate, cb, modifiedMeta);

};
