//  ██████╗ ███████╗███╗   ███╗ ██████╗ ██╗   ██╗███████╗    ███████╗██████╗  ██████╗ ███╗   ███╗
//  ██╔══██╗██╔════╝████╗ ████║██╔═══██╗██║   ██║██╔════╝    ██╔════╝██╔══██╗██╔═══██╗████╗ ████║
//  ██████╔╝█████╗  ██╔████╔██║██║   ██║██║   ██║█████╗      █████╗  ██████╔╝██║   ██║██╔████╔██║
//  ██╔══██╗██╔══╝  ██║╚██╔╝██║██║   ██║╚██╗ ██╔╝██╔══╝      ██╔══╝  ██╔══██╗██║   ██║██║╚██╔╝██║
//  ██║  ██║███████╗██║ ╚═╝ ██║╚██████╔╝ ╚████╔╝ ███████╗    ██║     ██║  ██║╚██████╔╝██║ ╚═╝ ██║
//  ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝ ╚═════╝   ╚═══╝  ╚══════╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝
//
//   ██████╗ ██████╗ ██╗     ██╗     ███████╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗
//  ██╔════╝██╔═══██╗██║     ██║     ██╔════╝██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║
//  ██║     ██║   ██║██║     ██║     █████╗  ██║        ██║   ██║██║   ██║██╔██╗ ██║
//  ██║     ██║   ██║██║     ██║     ██╔══╝  ██║        ██║   ██║██║   ██║██║╚██╗██║
//  ╚██████╗╚██████╔╝███████╗███████╗███████╗╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║
//   ╚═════╝ ╚═════╝ ╚══════╝╚══════╝╚══════╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝
//

var _ = require('@sailshq/lodash');
var async = require('async');

module.exports = function removeFromCollection(query, orm, cb) {
  // Validate arguments
  if (_.isUndefined(query) || !_.isPlainObject(query)) {
    throw new Error('Invalid arguments - missing `stageTwoQuery` argument.');
  }

  if (_.isUndefined(orm) || !_.isPlainObject(orm)) {
    throw new Error('Invalid arguments - missing `orm` argument.');
  }

  // Get the model being used as the parent
  var WLModel = orm.collections[query.using];

  // Look up the association by name in the schema definition.
  var schemaDef = WLModel.schema[query.collectionAttrName];

  // Look up the associated collection using the schema def which should have
  // join tables normalized
  var WLChild = orm.collections[schemaDef.collection];

  // Flag to determine if the WLChild is a manyToMany relation
  var manyToMany = false;

  // Check if the child is a join table
  if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
    manyToMany = true;
  }

  // Check if the child is a through table
  if (_.has(Object.getPrototypeOf(WLChild), 'throughTable') && _.keys(WLChild.throughTable).length) {
    manyToMany = true;
  }

  // Ensure the query skips lifecycle callbacks
  query.meta = query.meta || {};
  query.meta.skipAllLifecycleCallbacks = true;


  //  ███╗   ███╗ █████╗ ███╗   ██╗██╗   ██╗    ████████╗ ██████╗     ███╗   ███╗ █████╗ ███╗   ██╗██╗   ██╗
  //  ████╗ ████║██╔══██╗████╗  ██║╚██╗ ██╔╝    ╚══██╔══╝██╔═══██╗    ████╗ ████║██╔══██╗████╗  ██║╚██╗ ██╔╝
  //  ██╔████╔██║███████║██╔██╗ ██║ ╚████╔╝        ██║   ██║   ██║    ██╔████╔██║███████║██╔██╗ ██║ ╚████╔╝
  //  ██║╚██╔╝██║██╔══██║██║╚██╗██║  ╚██╔╝         ██║   ██║   ██║    ██║╚██╔╝██║██╔══██║██║╚██╗██║  ╚██╔╝
  //  ██║ ╚═╝ ██║██║  ██║██║ ╚████║   ██║          ██║   ╚██████╔╝    ██║ ╚═╝ ██║██║  ██║██║ ╚████║   ██║
  //  ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝          ╚═╝    ╚═════╝     ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝
  //
  // If the collection uses a join table, build a query that removes the records
  // from the table.
  if (manyToMany) {

    //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┬─┐┌─┐┌─┐┌─┐┬─┐┌─┐┌┐┌┌─┐┌─┐  ┌┬┐┌─┐┌─┐┌─┐┬┌┐┌┌─┐
    //  ╠╩╗║ ║║║   ║║  ├┬┘├┤ ├┤ ├┤ ├┬┘├┤ ││││  ├┤   │││├─┤├─┘├─┘│││││ ┬
    //  ╚═╝╚═╝╩╩═╝═╩╝  ┴└─└─┘└  └─┘┴└─└─┘┘└┘└─┘└─┘  ┴ ┴┴ ┴┴  ┴  ┴┘└┘└─┘
    //
    // Maps out the parent and child attribute names to use for the query.
    var parentReference;
    var childReference;

    // Find the parent reference
    if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
      // Assumes the generated junction table will only ever have two foreign key
      // values. Should be safe for now and any changes would need to be made in
      // Waterline-Schema where a map could be formed anyway.
      _.each(WLChild.schema, function(val, key) {
        if (!_.has(val, 'references')) {
          return;
        }

        // If this is the piece of the join table, set the parent reference.
        if (_.has(val, 'columnName') && val.columnName === schemaDef.on) {
          parentReference = key;
        }
      });
    }

    // If it's a through table, grab the parent and child reference from the
    // through table mapping that was generated by Waterline-Schema.
    else if (_.has(Object.getPrototypeOf(WLChild), 'throughTable')) {
      childReference = WLChild.throughTable[WLModel.identity + '.' + query.collectionAttrName];
      _.each(WLChild.throughTable, function(val, key) {
        if (key !== WLModel.identity + '.' + query.collectionAttrName) {
          parentReference = val;
        }
      });
    }

    // Find the child reference in a junction table
    if (_.has(Object.getPrototypeOf(WLChild), 'junctionTable') && WLChild.junctionTable) {
      // Assumes the generated junction table will only ever have two foreign key
      // values. Should be safe for now and any changes would need to be made in
      // Waterline-Schema where a map could be formed anyway.
      _.each(WLChild.schema, function(val, key) {
        if (!_.has(val, 'references')) {
          return;
        }

        // If this is the other piece of the join table, set the child reference.
        if (_.has(val, 'columnName') && val.columnName !== schemaDef.on) {
          childReference = key;
        }
      });
    }


    //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
    //  ╠╩╗║ ║║║   ║║  │─┼┐│ │├┤ ├┬┘└┬┘
    //  ╚═╝╚═╝╩╩═╝═╩╝  └─┘└└─┘└─┘┴└─ ┴
    //
    // If only a single targetRecordId is used, this can be done in a single
    // query. Otherwise multiple queries will be needed - one for each parent.

    // Build an array to hold all the records being removed
    var joinRecords = [];

    // For each target record, build a destroy query for the associated records.
    _.each(query.targetRecordIds, function(targetId) {
      var record = {};
      record[parentReference] = targetId;
      record[childReference] = query.associatedIds;
      joinRecords.push(record);
    });


    //  ╦═╗╦ ╦╔╗╔  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
    //  ╠╦╝║ ║║║║  │─┼┐│ │├┤ ├┬┘└┬┘
    //  ╩╚═╚═╝╝╚╝  └─┘└└─┘└─┘┴└─ ┴


    async.each(joinRecords, function(record, next) {
      WLChild.destroy(record, next, query.meta);
    }, function(err) {
      cb(err);
    });

    return;
  }


  //  ██████╗ ███████╗██╗      ██████╗ ███╗   ██╗ ██████╗ ███████╗    ████████╗ ██████╗
  //  ██╔══██╗██╔════╝██║     ██╔═══██╗████╗  ██║██╔════╝ ██╔════╝    ╚══██╔══╝██╔═══██╗
  //  ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██║  ███╗███████╗       ██║   ██║   ██║
  //  ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██║   ██║╚════██║       ██║   ██║   ██║
  //  ██████╔╝███████╗███████╗╚██████╔╝██║ ╚████║╚██████╔╝███████║       ██║   ╚██████╔╝
  //  ╚═════╝ ╚══════╝╚══════╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚══════╝       ╚═╝    ╚═════╝
  //
  // Otherwise the child records need to be updated to reflect the nulled out
  // foreign key value.


  //  ╔╗ ╦ ╦╦╦  ╔╦╗  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
  //  ╠╩╗║ ║║║   ║║  │─┼┐│ │├┤ ├┬┘└┬┘
  //  ╚═╝╚═╝╩╩═╝═╩╝  └─┘└└─┘└─┘┴└─ ┴


  // Build up a search criteria
  var criteria = {
    where: {}
  };

  criteria.where[WLChild.primaryKey] = query.associatedIds;
  criteria.where[schemaDef.via] = query.targetRecordIds;

  // Build up the values to update
  var valuesToUpdate = {};
  valuesToUpdate[schemaDef.via] = null;


  //  ╦═╗╦ ╦╔╗╔  ┌─┐ ┬ ┬┌─┐┬─┐┬ ┬
  //  ╠╦╝║ ║║║║  │─┼┐│ │├┤ ├┬┘└┬┘
  //  ╩╚═╚═╝╝╚╝  └─┘└└─┘└─┘┴└─ ┴

  return WLChild.update(criteria, valuesToUpdate, cb, query.meta);
};
